# Правила для разработки расширения VS Code "1C Platform Tools"

## Контекст проекта
Расширение для Visual Studio Code на TypeScript, предоставляющее инструменты для работы с проектами экосистемы 1С. Проект использует VS Code API для интеграции с редактором и vrunner (vanessa-runner) для выполнения команд 1С.

## Архитектура VS Code Extension
- **Точка входа**: `src/extension.ts` с `activate(context: vscode.ExtensionContext)`
- **Команды**: `vscode.commands.registerCommand()` с префиксом `1c-platform-tools.{commandName}`
- **Подписки**: все добавляются в `context.subscriptions` для автоматической очистки при деактивации
- **TreeView**: реализован через `vscode.window.createTreeView()` с `PlatformTreeDataProvider`
- **Типы**: всегда из `@types/vscode`, не использовать `any`
- **BaseCommand**: базовый класс для всех команд, предоставляет общие методы
- **VRunnerManager**: синглтон для работы с vrunner, управление путями и настройками
- **Активация**: при наличии файла `packagedef` в корне проекта

## Структура команд (разделение по доменам)
Команды организованы по доменам в `src/commands/`:
- `infobaseCommands.ts` - операции с информационными базами (создание, обновление, инициализация, выгрузка/загрузка dt)
- `configurationCommands.ts` - все операции с конфигурацией (загрузка, выгрузка, сборка, разбор)
- `extensionsCommands.ts` - все операции с расширениями (загрузка, выгрузка, сборка, разбор)
- `externalFilesCommands.ts` - операции с внешними файлами (обработки и отчеты: сборка, разбор)
- `dependenciesCommands.ts` - управление зависимостями через OPM
- `runCommands.ts` - запуск Предприятия и Конфигуратора
- `testCommands.ts` - тестирование (XUnit, Vanessa, синтаксический контроль, Allure)
- `setVersionCommands.ts` - установка версии (конфигурация, расширения, отчёты, обработки)
- `workspaceTasksCommands.ts` - управление задачами IDE и конфигурациями запуска
- `oscriptTasksCommands.ts` - задачи oscript (каталог `tasks/`, запуск .os файлов, добавление задачи)

## Соглашения по именованию методов
- `compile()` - сборка из исходников в бинарный файл (не `build()`)
- `decompile()` - разбор из бинарного файла в исходники
- `loadFromSrc()` - загрузка из исходников в ИБ
- `loadFromCf()` / `loadFromCfe()` - загрузка из файла в ИБ
- `dumpToSrc()` - выгрузка из ИБ в исходники
- `dumpToCf()` / `dumpToCfe()` - выгрузка из ИБ в файл

## Стиль кода
- **TypeScript**: strict mode, ES2022, модуль Node16
- **Комментарии и сообщения**: на русском языке
- **Коммиты**: Conventional Commits (https://www.conventionalcommits.org/ru/v1.0.0/)
- **ESLint**: camelCase/PascalCase для импортов, обязательные фигурные скобки, строгое равенство
- **Все классы команд**: наследуются от `BaseCommand` и используют `this.vrunner` для доступа к VRunnerManager
- **Все методы команд**: используют `this.ensureWorkspace()` для проверки workspace (НЕ использовать прямые проверки `getWorkspaceRoot()`)
- **Выполнение команд**: используют `this.vrunner.executeVRunnerInTerminal()` для выполнения в терминале
- **Импорты**: используйте `node:` префикс для Node.js модулей (например, `node:path`, `node:fs/promises`)
- **JSDoc**: все публичные методы должны иметь полную JSDoc документацию с `@param`, `@returns`, `@throws` где необходимо
- **Отладка**: НЕ использовать `console.log`, `console.error` в продакшн коде (использовать `vscode.window.showErrorMessage()` или отображение в UI)

## API VS Code (основные паттерны)
Подробная документация в `docs/vscode-api.md`

### Работа с workspace
- `vscode.workspace.workspaceFolders` - всегда проверять наличие перед работой с файлами
- `vscode.Uri` - использовать для путей файлов (не строки напрямую)
- `vscode.workspace.getConfiguration()` - получение настроек расширения

### Уведомления пользователю
- `vscode.window.showInformationMessage()` - информационные сообщения
- `vscode.window.showWarningMessage()` - предупреждения
- `vscode.window.showErrorMessage()` - ошибки
- `vscode.window.showQuickPick()` - выбор из списка
- `vscode.window.showInputBox()` - ввод текста

### Команды и терминалы
- `vscode.commands.registerCommand()` - регистрация команд
- `vscode.commands.executeCommand()` - выполнение команд
- `vscode.window.createTerminal()` - создание терминала для выполнения команд
- `vscode.window.activeTerminal` - активный терминал

### TreeView
- `vscode.window.createTreeView()` - создание дерева команд
- `vscode.TreeDataProvider` - провайдер данных для дерева

### Контекст
- `vscode.commands.executeCommand('setContext', 'key', value)` - установка контекста для условного отображения

## Структура проекта
- `src/extension.ts` - точка входа, регистрация команд, TreeView и настройка избранного
- `src/treeViewProvider.ts` - провайдер данных для дерева команд (включая динамические узлы: избранное, установка версии, задачи oscript)
- `src/treeStructure.ts` - единый источник данных для дерева и избранного (TREE_GROUPS, TreeCommandEntry, TreeGroup)
- `src/favorites.ts` - избранные команды (getPickableCommandsByGroup, FavoriteEntry, хранение в globalState)
- `src/vrunnerManager.ts` - менеджер для работы с vrunner (синглтон)
- `src/commandNames.ts` - утилиты для получения названий команд
- `src/commands/commandRegistry.ts` - централизованная регистрация всех команд расширения
- `src/commands/baseCommand.ts` - базовый класс для всех команд
- `src/commands/` - классы команд, разделенные по доменам (наследуются от BaseCommand)
- `src/utils/commandUtils.ts` - утилиты для работы с командами (escapeCommandArgs, buildCommand, joinCommands, buildDockerCommand, normalizeIbPathForDocker)
- `src/utils/configVersionUtils.ts` - утилиты для работы с версией конфигурации (установка версии)
- `src/utils/dateUtils.ts` - утилиты для работы с датами (formatDateForDtFileName)
- `src/constants.ts` - константы для работы с vanessa-runner
- `src/test/` - тесты (unit-тесты для утилит и BaseCommand)
- `resources/` - иконки (1c-icon.svg, 1c-icon.png)
- `out/` - скомпилированный код (генерируется)
- `docs/` - документация

## Сборка и разработка
- `npm run compile` - компиляция TypeScript
- `npm run watch` - режим наблюдения
- `npm run lint` - проверка ESLint
- `npm run test` - тесты (с `@vscode/test-electron`)
- `npm run package` - упаковка расширения в .vsix

## Важные правила

### Пути и файлы
- **Использовать относительные пути там, где это возможно**: пути к файлам внутри workspace должны быть относительными (например, `oscript_modules/bin/vrunner.bat` вместо абсолютного пути)
- **Пути к vrunner**: использовать `this.vrunner.getVRunnerPath()` (возвращает относительный путь `oscript_modules/bin/vrunner.bat` если найден в workspace, иначе `vrunner`)
- **Пути к исходникам**: использовать `this.vrunner.getCfPath()` (по умолчанию `src/cf`)
- **Путь к результатам сборки**: использовать `this.vrunner.getOutPath()` (по умолчанию `out`, ранее `build/out`)
- **Параметры подключения к ИБ**: использовать `await this.vrunner.getIbConnectionParam()` для получения параметра `--ibconnection` из `env.json` (возвращает массив `['--ibconnection', '/F./build/ib']`, использовать с spread оператором: `...ibConnectionParam`)

### Использование ibcmd
- **ibcmd**: утилита командной строки платформы 1С:Предприятие для ускорения операций с конфигурацией без запуска графического интерфейса Конфигуратора
- **Требование**: для работы ibcmd необходимо, чтобы платформа 1С:Предприятие была установлена с флагом **"Сервер 1С: Предприятия 8"**
- **Проверка настройки**: использовать `this.vrunner.getUseIbcmd()` для проверки, включена ли настройка использования ibcmd
- **Логика определения**: `getUseIbcmd()` возвращает `true` если:
  - Настройка `1c-platform-tools.useIbcmd = true` (явное включение)
  - ИЛИ настройка `1c-platform-tools.docker.enabled = true` (автоматически в Docker, так как нет GUI)
- **Добавление параметра**: использовать метод `this.addIbcmdIfNeeded(args)` из `BaseCommand` для добавления параметра `--ibcmd` при необходимости (вместо ручной проверки)
- **Команды, поддерживающие ibcmd**: операции с конфигурацией (загрузка, выгрузка, сборка, разбор), операции с расширениями, операции с информационными базами

### Работа с Docker
- **Поддержка Docker**: расширение поддерживает выполнение команд vrunner через Docker-контейнеры
- **Настройки**: `1c-platform-tools.docker.enabled` (boolean, default: false) и `1c-platform-tools.docker.image` (string, default: "")
- **Проверка использования Docker**: использовать `await this.vrunner.shouldUseDocker()` для проверки, нужно ли использовать Docker
- **Автоматическое использование ibcmd**: при работе в Docker (`docker.enabled = true`) параметр `--ibcmd` используется автоматически через `getUseIbcmd()`
- **Проверка поддержки ibcmd**: использовать `this.vrunner.supportsIbcmd(args)` для проверки, поддерживает ли команда `--ibcmd`
- **Ограничение**: в Docker можно выполнять только команды, которые поддерживают `--ibcmd` (операции с ИБ: init-dev, update-dev, dump, restore, dump-dt, load-dt; конфигурацией: load, dump, dumpcf, compile, decompile; расширениями: compileext, decompileext, unloadext, compileexttocfe; внешними файлами: compileepf, decompileepf). Команды запуска (run, designer) и тестирования (xunit, syntax-check, vanessa) не поддерживаются в Docker
- **Предупреждение**: при попытке выполнить команду без поддержки `--ibcmd` в Docker показывается предупреждение с возможностью отмены
- **Нормализация путей для Docker**: использовать `this.vrunner.processCommandArgsForDocker()` (публичный метод) для нормализации аргументов команды (преобразует пути в формат `/workspace/...`)
- **Получение Docker-образа**: использовать `this.vrunner.getDockerImage()` (публичный метод) для получения Docker-образа из настроек
- **Формирование Docker-команд**: использовать `buildDockerCommand()` из `src/utils/commandUtils.ts` для формирования команды `docker run`
- **Обработка путей ИБ**: пути в формате `/F./path` автоматически преобразуются в `/F./workspace/path` через `normalizeIbPathForDocker()`
- **ENTRYPOINT образов**: большинство образов vrunner имеют `ENTRYPOINT ["vrunner"]`, поэтому в команде не нужно указывать `vrunner` - только аргументы
- **Требования к образу**: Docker-образ должен содержать установленную платформу 1С:Предприятие и vanessa-runner
- **Выполнение команд**: `executeVRunnerInTerminal()` и `executeVRunner()` автоматически проверяют `shouldUseDocker()` и используют Docker при необходимости
- **Множественные команды**: при выполнении нескольких команд (например, для всех расширений) нужно проверять `shouldUseDocker()` и использовать `executeVRunnerInTerminal()` для каждой команды отдельно, если Docker включен. Если Docker выключен, можно использовать `executeCommandsInTerminal()` для последовательного выполнения в одном терминале

### Работа с терминалами и оболочками
- **Определение типа оболочки**: автоматически определяется через `detectShellType()` из настроек VS Code и переменных окружения
- **Поддерживаемые оболочки**: cmd, PowerShell, bash, sh, zsh (включая Git Bash на Windows)
- **Формирование команд**: использовать `buildCommand()` с автоматическим определением типа оболочки
- **Объединение команд**: использовать `joinCommands()` - в PowerShell используется `;`, в cmd и bash используется `&&`
- **Кодировка**: в PowerShell используется `[Console]::OutputEncoding`, в cmd используется `chcp 65001`, в bash оболочках на Windows кодировка обычно уже настроена
- **Экранирование аргументов**: автоматически адаптируется под тип оболочки (PowerShell использует одинарные кавычки, cmd/bash - двойные)
- **Экранирование специальных символов**: в PowerShell автоматически экранируются аргументы, содержащие пробелы, `$`, обратные кавычки `` ` `` или точку с запятой `;` (точка с запятой - разделитель команд в PowerShell)
- **Нормализация путей**: для bash оболочек на Windows (Git Bash, WSL) автоматически преобразуются обратные слэши `\` в прямые `/` в путях и аргументах команд
- **Автоматическая обработка аргументов**: методы `executeVRunnerInTerminal()`, `executeOpmInTerminal()`, `executeAllureInTerminal()` автоматически обрабатывают аргументы через `processCommandArgs()` (преобразуют абсолютные пути в относительные и нормализуют для оболочки)
- **Параметр shellType**: методы выполнения команд в терминале поддерживают опциональный параметр `shellType` для явного указания типа оболочки

### TreeView и избранное
- **Единый источник данных**: дерево команд и список команд для настройки избранного задаются в `src/treeStructure.ts` (TREE_GROUPS, TreeCommandEntry, TreeGroup). Добавление новой команды в дерево: добавить запись в соответствующую группу в `treeStructure.ts`.
- **Названия команд**: использовать функции из `src/commandNames.ts` (get*CommandName()) для полей `title` и `treeLabel` в TREE_GROUPS.
- **Избранное**: хранится в `vscode.Memento` (globalState), ключ задаётся в `src/favorites.ts`. Окно настройки избранного использует `getPickableCommandsByGroup()` из `favorites.ts` (данные из TREE_GROUPS).
- **Динамические узлы дерева**: провайдер дерева (`treeViewProvider.ts`) поддерживает узлы, заполняемые динамически — избранное (команды из globalState), «Установить версию» (расширения, отчёты, обработки из файловой системы), «Задачи (oscript)» (файлы из каталога `tasks/`). Регистрация обработчиков динамических узлов — в `extension.ts`.

### Регистрация команд
- Команды регистрируются в `package.json` → `contributes.commands`
- TreeView регистрируется в `package.json` → `contributes.views`
- Все команды должны быть зарегистрированы в `context.subscriptions`
- **Централизованная регистрация**: все команды регистрируются через `registerCommands()` в `src/commands/commandRegistry.ts`
- **Избегать множественных push()**: при регистрации команд использовать массивы и один вызов `push()` со spread оператором

### Организация кода
- Команды должны быть организованы по доменам, а не по типам операций
- Все классы команд должны наследоваться от `BaseCommand`
- Для сборки использовать метод `compile()`, а не `build()`
- Все классы команд должны быть экспортируемыми и иметь понятные имена
- **ОБЯЗАТЕЛЬНО**: Использовать `this.ensureWorkspace()` вместо ручной проверки `this.vrunner.getWorkspaceRoot()` - это обеспечивает единообразную обработку ошибок
- Использовать методы `BaseCommand` для работы с файловой системой (`checkDirectoryExists`, `getDirectories`, `getFilesByExtension`)
- Использовать `this.addIbcmdIfNeeded(args)` для добавления параметра `--ibcmd` при необходимости
- Использовать `this.vrunner.executeVRunnerInTerminal()` для выполнения команд в терминале
- Использовать `this.vrunner.executeVRunner()` только для проверок и синхронных операций
- Использовать `this.vrunner.executeOpmInTerminal()` и `this.vrunner.executeAllureInTerminal()` для выполнения соответствующих команд (они автоматически обрабатывают аргументы)
- Все асинхронные методы должны возвращать `Promise<void>` или `Promise<T>` с соответствующим типом
- JSDoc комментарии должны быть полными: описывать что делает метод, параметры, возвращаемое значение, возможные исключения
- **Рефакторинг**: выносить общую логику в приватные методы классов команд (например, создание терминала, получение списка файлов)
- **Избегать множественных push()**: при работе с массивами использовать один вызов `push()` со spread оператором или `concat()`

### Обработка ошибок
- Всегда обрабатывать ошибки при работе с файловой системой
- Использовать try-catch для асинхронных операций
- Показывать понятные сообщения об ошибках пользователю через `vscode.window.showErrorMessage()`
- НЕ использовать `console.error` для логирования ошибок - вместо этого показывать ошибки в UI или использовать механизмы VS Code для логирования
- При ошибках в TreeView отображать информационные элементы с описанием ошибки вместо скрытия проблемы

### Производительность
- Избегать синхронных операций с файловой системой в основном потоке
- Использовать асинхронные версии (`fs/promises`) вместо синхронных
- Кэшировать результаты, где это возможно

## Документация
Подробная документация находится в папке `docs/`:
- `README.md` - навигация по документации
- `vscode-api.md` - паттерны использования VS Code API
- `vrunner-patterns.md` - паттерны работы с vrunner
- `CI_CD_SETUP.md` - настройка CI/CD

Информация о Docker интегрирована в основной `README.md` проекта.

## JSDoc стандарты
- Все публичные методы классов должны иметь JSDoc комментарии
- Формат: описание метода, `@param` для каждого параметра, `@returns` для возвращаемого значения, `@throws` для исключений
- Для асинхронных методов указывать "Промис, который разрешается..."
- **ЗАПРЕЩЕНО использовать `@example` в JSDoc комментариях** - примеры использования не должны включаться в документацию
- Пример:
  ```typescript
  /**
   * Загружает конфигурацию из исходников в информационную базу
   * @param mode - Режим загрузки: 'init' для инициализации, 'update' для обновления
   * @returns Промис, который разрешается после запуска команды
   */
  async loadFromSrc(mode: 'init' | 'update' = 'update'): Promise<void>
  ```

## Чистота кода
- Удалять лишние комментарии, которые дублируют код
- Удалять отладочную информацию (`console.log`, `console.error`) перед коммитом
- Комментарии должны объяснять "почему", а не "что" (код сам объясняет "что")
- Исключение: комментарии для разделения секций в больших файлах (например, в `commandNames.ts`)

## Тестирование
- Unit-тесты для утилит находятся в `src/test/utils/`
- Тесты для BaseCommand находятся в `src/test/commands/baseCommand.test.ts`
- Использовать фикстуры из `src/test/fixtures/` для создания тестовых workspace
- Все тесты должны использовать `createTestContext()` для создания временных workspace
